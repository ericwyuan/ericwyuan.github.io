{"meta":{"title":"Eric's Blog","subtitle":null,"description":null,"author":"Eric","url":"http://ericwyuan.com","root":"/"},"pages":[{"title":"categories","date":"2019-06-02T02:38:36.000Z","updated":"2020-03-15T06:14:56.225Z","comments":true,"path":"categories/index.html","permalink":"http://ericwyuan.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-02T03:55:37.000Z","updated":"2020-03-15T06:14:56.224Z","comments":true,"path":"about/index.html","permalink":"http://ericwyuan.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-02T02:38:59.000Z","updated":"2020-03-15T06:14:56.225Z","comments":true,"path":"tags/index.html","permalink":"http://ericwyuan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java数据结构-（一）","slug":"Java数据结构-（一）","date":"2020-03-22T10:44:15.000Z","updated":"2020-03-22T13:03:41.310Z","comments":true,"path":"Java数据结构-（一）.html","link":"","permalink":"http://ericwyuan.com/Java数据结构-（一）.html","excerpt":"","text":"1.接口 Collection Set Map List Queue Stack2.常用哪些 排序 常用方法3.实现原理 各个Jdk版本优化4.存储结构 链表 数组 初始化容量 扩容机制 优点5.线程安全 线程安全实现方式 继承关系 注意List和Set继承Collection Map没有继承Collection List1.ArrayList2.LinkedList3.CopyOnWriteArrayList ArrayList1.内部通过数据实现 1transient Object[] array; 2.扩容机制 123456789101112131415161718private static final int MIN_CAPACITY_INCREMENT = 12;@Override public boolean add(E object) &#123; Object[] a = array; int s = size; if (s == a.length) &#123; //当前容量 小于6个 增加12个位置 大于6个 增加一倍 Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)]; System.arraycopy(a, 0, newArray, 0, s); array = a = newArray; &#125; a[s] = object; size = s + 1; modCount++; return true;&#125; 3.线程不安全 多线程会出现ConcurrentModificationException异常 LinkedList1.内部通过链表来实现 12345678910111213transient Link&lt;E&gt; voidLink;private static final class Link&lt;ET&gt; &#123; ET data; Link&lt;ET&gt; previous, next; Link(ET o, Link&lt;ET&gt; p, Link&lt;ET&gt; n) &#123; data = o; previous = p; next = n; &#125;&#125; 2.扩容机制 不存在扩容问题 123456789private boolean addLastImpl(E object) &#123; Link&lt;E&gt; oldLast = voidLink.previous; Link&lt;E&gt; newLink = new Link&lt;E&gt;(object, oldLast, voidLink); voidLink.previous = newLink; oldLast.next = newLink; size++; modCount++; return true;&#125; 3.同样线程不安全 多线程会出现ConcurrentModificationException异常4.比较ArrayList LinkedListArrayList 在中间插入数据比较负责 需要做拷贝工作 寻找数据比较简单 数组下标LinkedList在任意位置插入数据比较简单 链表操作 查找数据比较复杂 遍历列表 CopyOnWriteArrayList1.内部通过数组实现 初始化容量是0 1private transient volatile Object[] elements; 2.扩容机制不存在扩容问题 每次生成一个N+1的数组 将之前的数据拷过来 新的数据追加在后边 123456public synchronized boolean add(E e) &#123; Object[] newElements = new Object[elements.length + 1]; System.arraycopy(elements, 0, newElements, 0, elements.length); newElements[elements.length] = e; elements = newElements; return true;&#125; 3.线程安全线程安全 add addAll clear remove都是synchronized方法 Map1.HashMap2.HashTable3.TreeMap4.LinkedHashMap5.ConcurrentHashMap6.ConcurrentSkipListMap HashMap1.初始化 12345678910111213141516171819202122232425262728293031323334353637/** * 负载因子 0.75 * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 初始化容量为16 * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//内部第一层数据结构为数组transient Node&lt;K,V&gt;[] table; //内部第二层数据结构为链表static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125;/** * &gt;&gt;&gt;为无符号左移 支持负数 -1是为了传进来的数组是4这种 生成一个比传进来的数大的2的幂 * 111111+1 这样的 * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 2.Put方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //当前为容量0调用resize方法 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //不存在Hash冲突 直接放进去 tab[i] = newNode(hash, key, value, null); else &#123; //存在Hash冲突 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //Value值相等 则直接替换 e = p; else if (p instanceof TreeNode) //Next已经为TreeNode 在数中插入 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //放入到最后一个位置 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //如果总数大于7了 转化为树状结构 treeifyBin(tab, hash); break; &#125; //key相等 做替换 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) //size大于推荐容量 需要调用resize resize(); afterNodeInsertion(evict); return null;&#125;/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 3.线程不安全 HashTable1.内部数据结构 1234567891011121314 /** * 第一层 为数组 * The hash table data. */ private transient Entry&lt;?,?&gt;[] table; //第二层 为链表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Entry&lt;K,V&gt; next;&#125; put方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; //遇到valuse是空 跑抛出异常 throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; //当前位置存在Hash冲突 if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; 遇到相等的 则替换 V old = entry.value; entry.value = value; return old; &#125; &#125; //当前位置不存在Hash冲突 addEntry(hash, key, value, index); return null;&#125;private void addEntry(int hash, K key, V value, int index) &#123; modCount++; Entry&lt;?,?&gt; tab[] = table; if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded //重新计算容量 rehash(); tab = table; hash = key.hashCode(); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 3.HashMap和HashTable区别HashMap是允许key和value为null值的，用containsValue和containsKey方法判断是否包含对应键值对；HashTable键值对都不能为空，否则报空指针异常。 TreeMap1.内部实现 12345678910111213141516//通过红黑树实现private transient Entry&lt;K,V&gt; root;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK;&#125;//Key需要实现Comparator方法public TreeMap() &#123; comparator = null;&#125; 2.不存在扩容问题3.线程不安全 LinkedHashMap1.内部实现 继承HashMap 1234567891011121314151617181920/** * 通过链表记录顺序 * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * 支持按照插入或者访问排序 * @serial */final boolean accessOrder; 2.put方法 123456789101112131415161718//put方法使用HashMap的put方法 重写了newNode方法 记录了插入顺序Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125;private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; ConcurrentHashMap一个线程安全且高效的HashMap实现 采用了 CAS + synchronized 来保证并发安全性 1.内部实现 1234567891011121314/** * The array of bins. Lazily initialized upon first insertion. * Size is always a power of two. Accessed directly by iterators. * 第一层数据格式为数组 */transient volatile Node&lt;K,V&gt;[] table;//第二层数据格式为链表static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next;&#125; 2.put方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //计算HashKey int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化table tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; //锁住当前Node进行操作 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125;","categories":[],"tags":[]},{"title":"Android-Vpn总结","slug":"Android-Vpn总结","date":"2020-03-22T07:25:03.000Z","updated":"2020-03-22T10:17:56.107Z","comments":true,"path":"Android-Vpn总结.html","link":"","permalink":"http://ericwyuan.com/Android-Vpn总结.html","excerpt":"","text":"Android Vpn实现分类iptablesAndroid平台的透明代理早期都是基于NAT来实现的，netfilter模块内部有三张表，mangle, filter和nat。 修改地址转换或者端口转发 实现Vpn VpnService早期的Android版本只支持内置的VPN连接，VPN服务器必须是标准的PPTP或者L2TP/IPSec实现，从Android 4.0开始，SDK提供了VpnService系列的接口，允许开发者实现自定义的VPN协议。这套API提供了拦截IP包的能力，给开发者提供了高度的可定制性。 socks代理将接受到的数据库转发到一个Socket服务器 实现代理功能 VpnService原理如图所示 VpnService启动后 会生成一个新的Tun虚拟网卡 手机上所有流量会经过这个虚拟网卡 根据协议 Tun虚拟网卡接受到Ip层的包 需要特殊解析SYN FIN等特殊协议字命令 VpnService应用网址检测 建立类继承VpnService 从虚拟网卡读取Byte数据 此数据为Ip层数据 Ip层可以判断是IpV4 IpV6 TCP UDP 做不同处理 通过Tcp头解析出Ip地址与端口与data 通过Tcp头判断是不是Http请求 如果是Http请求 获取Host 检测Ip和Host 判断是否合法 允许访问 不需要则返回503 允许则继续 允许访问 将data封装为改短口发出去的数据 Tun虚拟网卡与真正服务器通信 真正服务器返回的数据到虚拟网卡 修改Ip与Tcp头后 从虚拟网卡写入到VpnService的FileOutputStream(mVpnFileDescriptor)中 注意点1.避免发生循环问题 与真正服务器连接的Socket连接需要是用protect2.提高效率 需要4个优先队列LinkedBlockingQueue Tcp2Net Udp2Net Net2Device CurrentTcp2Net(优先处理当前应用的数据)3.需要特别关注Host和端口号 写入和写出的需要对换 计算校验和4.步骤7需要处理Tcp特殊字段 遇到Syn的字段不需要处理 需要发起连接 当连接建立成功的时候 给客户端发送SYN+ACK的特殊信息5.需要FIN 需要关闭客户端建立的连接6.是用Netty Nio包 提高效率 Bootstrap ChannelOutboundHandlerAdapter ChannelInboundHandlerAdapter7.addDisallowedApplication方法 过滤哪些包不经过Vpn可以直接发给服务器 21以下没有这个方法 需要解析/proc/net/tcp文件 有Uid和端口的对应关系 可代替实现8.需要是用Lru管理缓存 防止有些连接长时间过期 不处理9.需要使用Lru管理缓存 遇到已处理的网址不需要额外再去服务器检查","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"}]},{"title":"Picasso源码梳理","slug":"Picasso源码梳理","date":"2019-07-01T06:23:51.000Z","updated":"2020-03-15T06:14:56.223Z","comments":true,"path":"Picasso源码梳理.html","link":"","permalink":"http://ericwyuan.com/Picasso源码梳理.html","excerpt":"","text":"添加依赖1implementation \"com.squareup.picasso:picasso:2.4.0\" 简单使用123Picasso.with(this) .load(\"http://****.jpg\") .into(mImageView); 初始化梳理123456789101112131415161718192021222324252627282930313233343536373839public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton;&#125; public Picasso build() &#123; Context context = this.context; //初始化图片下载器 if (downloader == null) &#123; downloader = Utils.createDefaultDownloader(context); &#125; //初始化Lru缓存 使用LinkedHashMap实现 if (cache == null) &#123; cache = new LruCache(context); &#125; //初始化线程池 if (service == null) &#123; service = new PicassoExecutorService(); &#125; if (transformer == null) &#123; transformer = RequestTransformer.IDENTITY; &#125; Stats stats = new Stats(cache); //初始化一个分发器 Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, indicatorsEnabled, loggingEnabled); &#125;&#125; Load流程梳理123456789101112131415public RequestCreator load(String path) &#123; if (path == null) &#123; return new RequestCreator(this, null, 0); &#125; if (path.trim().length() == 0) &#123; throw new IllegalArgumentException(\"Path must not be empty.\"); &#125; //将String转化为Uri对象 return load(Uri.parse(path));&#125;//返回一个请求创造对象public RequestCreator load(Uri uri) &#123; return new RequestCreator(this, uri, 0);&#125; init流程梳理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); //在主线程调用直接拋出异常 checkMain(); //判断View是否存在 if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; //判断请求对象 if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123; if (data.hasSize()) &#123; throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; //生成请求对象与Key作为唯一标识 Request request = createRequest(started); String requestKey = createKey(request); //从内存Cache中找一遍 if (!skipMemoryCache) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; //是否设置了占位图片 if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; //新建一个请求Action Action action = new ImageViewAction(picasso, target, request, skipMemoryCache, noFade, errorResId, errorDrawable, requestKey, tag, callback); picasso.enqueueAndSubmit(action);&#125;void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action);&#125; 多类型资源处理流程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//有下面这些资源的处理能力 他们回依次执行 List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; //客户端自己实现的RequestHandlers 默认为空 allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); //依次去上边几个RequestHandler中去请求 for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; //ResourceRequestHandler 本地资源文件 判断scheme @Override public boolean canHandleRequest(Request data) &#123; if (data.resourceId != 0) &#123; return true; &#125; return SCHEME_ANDROID_RESOURCE.equals(data.uri.getScheme()); &#125; //ContactsPhotoRequestHandler 联系人 @Override public boolean canHandleRequest(Request data) &#123; final Uri uri = data.uri; return (SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; ContactsContract.Contacts.CONTENT_URI.getHost().equals(uri.getHost()) &amp;&amp; !uri.getPathSegments().contains(ContactsContract.Contacts.Photo.CONTENT_DIRECTORY)); &#125; //MediaStoreRequestHandler 媒体库 @Override public boolean canHandleRequest(Request data) &#123; final Uri uri = data.uri; return (SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; MediaStore.AUTHORITY.equals(uri.getAuthority())); &#125; //ContentStreamRequestHandler Content @Override public boolean canHandleRequest(Request data) &#123; return SCHEME_CONTENT.equals(data.uri.getScheme()); &#125; //AssetRequestHandler assets中资源 @Override public boolean canHandleRequest(Request data) &#123; Uri uri = data.uri; return (SCHEME_FILE.equals(uri.getScheme()) &amp;&amp; !uri.getPathSegments().isEmpty() &amp;&amp; ANDROID_ASSET.equals(uri.getPathSegments().get(0))); &#125; //FileRequestHandler 文件资源 @Override public boolean canHandleRequest(Request data) &#123; return SCHEME_FILE.equals(data.uri.getScheme()); &#125; //NetworkRequestHandler 最后一个网络资源 @Override public boolean canHandleRequest(Request data) &#123; String scheme = data.uri.getScheme(); return (SCHEME_HTTP.equals(scheme) || SCHEME_HTTPS.equals(scheme)); &#125; 网络请求流程梳理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Override public Result load(Request data) throws IOException &#123; //加入到下载器中 支持Okhttp和UrlConnection 有OKhttp优先使用Okhttp //Picsso没有自己实现硬盘缓存 他的硬盘缓存通过Http的头文件来控制的 //extraRequestHandlers 可以自己实现 Response response = downloader.load(data.uri, data.loadFromLocalCacheOnly); if (response == null) &#123; return null; &#125; Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; return new Result(bitmap, loadedFrom); &#125; InputStream is = response.getInputStream(); if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven't found // root cause to this but retrying the request seems safe to do so. if (response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new IOException(\"Received response with 0 content-length header.\"); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; try &#123; return new Result(decodeStream(is, data), loadedFrom); &#125; finally &#123; Utils.closeQuietly(is); &#125;&#125;//OkHttp网络请求流程@Override public Response load(Uri uri, boolean localCacheOnly) throws IOException &#123; HttpURLConnection connection = openConnection(uri); connection.setUseCaches(true); //网络层的缓存 if (localCacheOnly) &#123; connection.setRequestProperty(\"Cache-Control\", \"only-if-cached,max-age=\" + Integer.MAX_VALUE); &#125; int responseCode = connection.getResponseCode(); if (responseCode &gt;= 300) &#123; connection.disconnect(); throw new ResponseException(responseCode + \" \" + connection.getResponseMessage()); &#125; String responseSource = connection.getHeaderField(RESPONSE_SOURCE_OKHTTP); if (responseSource == null) &#123; responseSource = connection.getHeaderField(RESPONSE_SOURCE_ANDROID); &#125; long contentLength = connection.getHeaderFieldInt(\"Content-Length\", -1); boolean fromCache = parseResponseSourceHeader(responseSource); return new Response(connection.getInputStream(), fromCache, contentLength);&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"源码梳理","slug":"源码梳理","permalink":"http://ericwyuan.com/tags/源码梳理/"}]},{"title":"反编译APK","slug":"反编译APK","date":"2019-07-01T03:28:21.000Z","updated":"2020-03-15T06:14:56.223Z","comments":true,"path":"反编译APK.html","link":"","permalink":"http://ericwyuan.com/反编译APK.html","excerpt":"","text":"APK反编译脚本同目录下放一个bin文件夹 里边放dex2jar apktool相关文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# coding=utf-8import osimport shutilimport sysimport zipfilereload(sys)sys.setdefaultencoding('utf8')def extract_to(z_file, path): for p in z_file.namelist(): extract(z_file, p, path)def extract(z_file, filename, path): try: if not filename.endswith('/'): f = os.path.join(path, filename) dir = os.path.dirname(f) if not os.path.exists(dir): os.makedirs(dir) file(f, 'wb').write(z_file.read(filename)) except BaseException: passfile_name_postfix = [\"_Jar\", \"_Res\", \"_Rar\"]file_name_dict = &#123;&#125;def reverse_apk(): # 1.反编译APK 获取res AndroidManifest.xml assets资源 # 2.读取APK 解压缩获取相关签名信息 # 3.反编译APK 获取Jar资源文件 if os.path.exists(\"out\"): shutil.rmtree(\"out\") os.mkdir(\"out\") for file_name in os.listdir(os.getcwd()): if file_name.endswith(\"apk\"): print file_name # 创建该项目的输出目录 parent_dir = \"out\\\\\" + file_name.replace(\".apk\", \"\") if os.path.exists(parent_dir): shutil.rmtree(parent_dir) os.mkdir(parent_dir) # 创建该项目各个资源的输出路径 for postfix in file_name_postfix: file_dir = parent_dir + \"\\\\\" + file_name.replace(\".apk\", \"\") + postfix if os.path.exists(file_dir): shutil.rmtree(file_dir) os.mkdir(file_dir) file_name_dict[postfix] = parent_dir + \"\\\\\" + file_name.replace(\".apk\", \"\") + postfix # 反编译APK 获取res AndroidManifest.xml assets资源 os.system(\"bin\\\\apktool\\\\apktool.bat d -f \" + file_name) shutil.rmtree(file_name_dict[\"_Res\"]) os.rename(file_name.replace(\".apk\", \"\"), file_name_dict[\"_Res\"]) # 读取APK 解压缩获取相关签名信息 try: z_file = zipfile.ZipFile(file_name, mode='r') extract_to(z_file, file_name_dict[\"_Rar\"]) for rsa_file_name in os.listdir(file_name_dict[\"_Rar\"] + \"\\\\META-INF\"): if rsa_file_name.endswith(\"RSA\") or rsa_file_name.endswith(\"rsa\"): os.rename(file_name_dict[\"_Rar\"] + \"\\\\META-INF\\\\\" + rsa_file_name, file_name_dict[\"_Rar\"] + \"\\\\META-INF\\\\CERT.p7b\") except BaseException, e: print e continue # 反编译APK 获取Jar资源文件 for dex_file in os.listdir(file_name_dict[\"_Rar\"]): # 多dex处理 if dex_file.endswith(\"dex\"): cmd = \"bin\\\\dex2jar\\\\d2j-dex2jar.bat --force \" + file_name_dict[ \"_Rar\"] + \"\\\\\" + dex_file + \" -o \" + file_name_dict[ \"_Jar\"] + \"\\\\\" + dex_file.replace(\".dex\", \".jar\") print cmd os.system(cmd)# androi反编译if __name__ == \"__main__\": try: reverse_apk() except BaseException, e: print eraw_input('Press enter to exit...')","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://ericwyuan.com/tags/Python/"}]},{"title":"OkHttp源码梳理","slug":"OkHttp源码梳理","date":"2019-06-05T08:17:05.000Z","updated":"2020-03-22T13:11:17.707Z","comments":true,"path":"OkHttp源码梳理.html","link":"","permalink":"http://ericwyuan.com/OkHttp源码梳理.html","excerpt":"","text":"添加依赖1implementation 'com.squareup.okhttp3:okhttp:3.10.0' 使用方法1234567891011121314151617181920212223242526272829OkHttpClient client = new OkHttpClient();Request request = new Request.Builder().url(\"http://www.baidu.com\").build();try &#123; //同步流程 Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123;System.out.println(\"成功\"); &#125;&#125; catch (Throwable t) &#123; t.printStackTrace();&#125;try &#123; //异步流程 client.newCall(request).enqueue(new Callback() &#123;@Overridepublic void onFailure(Call call, IOException e) &#123; System.out.println(\"失败\");&#125;@Overridepublic void onResponse(Call call, Response response) throws IOException &#123; System.out.println(\"成功\");&#125; &#125;);&#125; catch (Throwable t) &#123; t.printStackTrace();&#125; 发起请求加入各种拦截器 用到责任链的思想 1.客户端自定义的拦截器 可以做一些日志的打印2.重试与重定向拦截器 哪些请求需要重试 重试策略 哪些请求需要重定向之类3.桥接拦截器 将客户端的request对象转化为一个服务器认识的请求 添加头信息 cookie等信息4.缓存拦截器 判断哪些请求是不需要走服务器 可以直接走缓存的处理5.连接拦截器 建立 获取一个有效的服务器连接6.客户端自定义的拦截器 可以做一些向服务器传递之前的统一操作 添加公共参数 url签名校验 包体加密等7.调用服务拦截器 真正的与服务器交互的拦截器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Override public Response execute() throws IOException &#123;synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true;&#125;captureCallStackTrace();eventListener.callStart(this);try &#123; //加入到分发丢了 client.dispatcher().executed(this); //这步才是真正的执行 前面是一些条件的判断 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result;&#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e;&#125; finally &#123; //从分发队列删除 client.dispatcher().finished(this);&#125;&#125;Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //加入各种拦截器 用到责任链的思想 //有客户端传进来的 有内置的拦截器 //客户端自定义的拦截器 可以做一些日志的打印 interceptors.addAll(client.interceptors()); //重试与重定向拦截器 哪些请求需要重试 重试策略 哪些请求需要重定向之类 interceptors.add(retryAndFollowUpInterceptor); //桥接拦截器 将客户端的request对象转化为一个服务器认识的请求 添加头信息 cookie等信息 interceptors.add(new BridgeInterceptor(client.cookieJar())); //缓存拦截器 判断哪些请求是不需要走服务器 可以直接走缓存的处理 interceptors.add(new CacheInterceptor(client.internalCache())); //连接拦截器 建立 获取一个有效的服务器连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; //客户端自定义的拦截器 可以做一些向服务器传递之前的统一操作 添加公共参数 url签名校验 包体加密等 interceptors.addAll(client.networkInterceptors()); &#125; //调用服务拦截器 真正的与服务器交互的拦截器 interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 具体执行每个拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must retain the same host and port\"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must call proceed() exactly once\"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); //执行这个拦截器的具体操作 Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( \"interceptor \" + interceptor + \" returned a response with no body\"); &#125; return response;&#125; RetryAndFollowUpInterceptor 重试与重定向拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238@Override public Response intercept(Chain chain) throws IOException &#123; //chain是下一个拦截器对象 Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); //初始化一个request管理对象 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(\"Canceled\"); &#125; Response response; boolean releaseConnection = true; try &#123; //执行下一个拦截器做真正处理 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; //如果上一次返回的结果不为空 对response做修改 // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; //对返回结果进行处理 看是否需要重新请求 Request followUp = followUpRequest(response, streamAllocation.route()); //不需要重新请求 返回结果 if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; //请求网址与返回的网址不一致 需要进行重新请求 if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; //记录下一次请求的request对象 request = followUp; //记录上一次请求的请求结果 priorResponse = response; &#125;&#125;/** * Figures out the HTTP request to make in response to receiving &#123;@code userResponse&#125;. This will * either add authentication headers, follow redirects or handle a client request timeout. If a * follow-up is either unnecessary or not applicable, this returns null. */private Request followUpRequest(Response userResponse, Route route) throws IOException &#123; if (userResponse == null) throw new IllegalStateException(); int responseCode = userResponse.code(); final String method = userResponse.request().method(); //根据responseCode进行处理 switch (responseCode) &#123; case HTTP_PROXY_AUTH: Proxy selectedProxy = route != null ? route.proxy() : client.proxy(); if (selectedProxy.type() != Proxy.Type.HTTP) &#123; throw new ProtocolException(\"Received HTTP_PROXY_AUTH (407) code while not using proxy\"); &#125; return client.proxyAuthenticator().authenticate(route, userResponse); case HTTP_UNAUTHORIZED: return client.authenticator().authenticate(route, userResponse); case HTTP_PERM_REDIRECT: case HTTP_TEMP_REDIRECT: // \"If the 307 or 308 status code is received in response to a request other than GET // or HEAD, the user agent MUST NOT automatically redirect the request\" if (!method.equals(\"GET\") &amp;&amp; !method.equals(\"HEAD\")) &#123; return null; &#125; // fall-through case HTTP_MULT_CHOICE: case HTTP_MOVED_PERM: case HTTP_MOVED_TEMP: case HTTP_SEE_OTHER: //重定向处理 // Does the client allow redirects? if (!client.followRedirects()) return null; //获取重定向地址 构建请求对象 String location = userResponse.header(\"Location\"); if (location == null) return null; HttpUrl url = userResponse.request().url().resolve(location); // Don't follow redirects to unsupported protocols. if (url == null) return null; // If configured, don't follow redirects between SSL and non-SSL. boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; // Most redirects don't include a request body. Request.Builder requestBuilder = userResponse.request().newBuilder(); if (HttpMethod.permitsRequestBody(method)) &#123; final boolean maintainBody = HttpMethod.redirectsWithBody(method); if (HttpMethod.redirectsToGet(method)) &#123; requestBuilder.method(\"GET\", null); &#125; else &#123; RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); &#125; if (!maintainBody) &#123; requestBuilder.removeHeader(\"Transfer-Encoding\"); requestBuilder.removeHeader(\"Content-Length\"); requestBuilder.removeHeader(\"Content-Type\"); &#125; &#125; // When redirecting across hosts, drop all authentication headers. This // is potentially annoying to the application layer since they have no // way to retain them. if (!sameConnection(userResponse, url)) &#123; requestBuilder.removeHeader(\"Authorization\"); &#125; return requestBuilder.url(url).build(); case HTTP_CLIENT_TIMEOUT: //请求超时处理 // 408's are rare in practice, but some servers like HAProxy use this response code. The // spec says that we may repeat the request without modifications. Modern browsers also // repeat the request (even non-idempotent ones.) // 如果设定不处理超时 则跳过 if (!client.retryOnConnectionFailure()) &#123; // The application layer has directed us not to retry the request. return null; &#125; if (userResponse.request().body() instanceof UnrepeatableRequestBody) &#123; return null; &#125; if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; if (retryAfter(userResponse, 0) &gt; 0) &#123; return null; &#125; return userResponse.request(); case HTTP_UNAVAILABLE: if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123; // specifically received an instruction to retry without delay return userResponse.request(); &#125; return null; default: return null; &#125;&#125;private int retryAfter(Response userResponse, int defaultDelay) &#123; String header = userResponse.header(\"Retry-After\"); if (header == null) &#123; return defaultDelay; &#125; // https://tools.ietf.org/html/rfc7231#section-7.1.3 // currently ignores a HTTP-date, and assumes any non int 0 is a delay if (header.matches(\"\\\\d+\")) &#123; return Integer.valueOf(header); &#125; return Integer.MAX_VALUE;&#125; BridgeInterceptor 桥梁拦截器（客户端代码和网络代码的桥接）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); //将客户端的一个request对象转化为服务器认识的对象 设置一些请求头 设置cookie等信息 RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; //默认支持Keep-Alive if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; //默认支持gzip压缩 // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null &amp;&amp; userRequest.header(\"Range\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125; //设置cookie信息 List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; //执行下一个拦截器 CacheInterceptor Response networkResponse = chain.proceed(requestBuilder.build()); //存储cookie信息 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build();&#125; CacheInterceptor 缓存拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //从缓存中过滤 是否需要去网络拉取数据 这个逻辑比较重要 需要分析 看下如何判断是否需要走缓存的逻辑 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; //网络请求Request为空 则说明不需要去网络请求 //同时结果缓存中没数据 则直接返回504并说明是从缓存中获取 // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; //网络请求Request为空 同时缓存中有数据 则从缓存中取出数据 返回 // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //执行下一个拦截器 ConnectInterceptor networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; //对304错误码进行特殊处理 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //加入缓存请求结果与网络请求结果 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //对缓存进行更新 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; ConnectInterceptor 建立Socket连接拦截器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); //去创建一个HttpCodec(HTTP1 HTTP2)和RealConnection对象 赋予到下一个请求参数中 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125;public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; //找到一个可用的RealConnection 并获取他的HTTP版本号 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125;private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; //无限循环直到找到一个真正可用的socket RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); //这个连接是新建立的 则跳过Socket可用性检查 synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. //判断socket是否可用 if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; noNewStreams(); continue; &#125; return candidate; &#125;&#125; CallServerInterceptor 真正的与服务器交换数据的拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100 // Continue\" response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // Write the request body if the \"Expect: 100-continue\" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); //将数据写入到对应的嗯连接中 使用的是okio request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); //开始获取服务器返回数据 if (responseBuilder == null) &#123; //获取服务器返回的头信息 realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) &#123; // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() //获取服务器返回的body信息 .body(httpCodec.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"源码梳理","slug":"源码梳理","permalink":"http://ericwyuan.com/tags/源码梳理/"}]},{"title":"EventBus源码梳理","slug":"EventBus源码梳理","date":"2019-06-05T03:49:21.000Z","updated":"2020-03-22T10:17:56.112Z","comments":true,"path":"EventBus源码梳理.html","link":"","permalink":"http://ericwyuan.com/EventBus源码梳理.html","excerpt":"","text":"梳理下EventBus源码Git地址 添加依赖1implementation 'org.greenrobot:eventbus:3.1.1' 使用方法 定义消息实体: 1public static class MessageEvent &#123; /* Additional fields if needed */ &#125; 订阅类: 1234567891011121314151617 //回调方法 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;//注册与反注册@Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; //反注册 @Override public void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this); &#125; 发送消息: 1EventBus.getDefault().post(new MessageEvent()); 注册逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161//注册的入口 @Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //查看这个类是不是被遍历过 如果之前遍历过 则直接返回缓存中的数据 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); &#125; else &#123; //将注册方法缓存 key是类 value是回调方法List 并返回所有回调方法 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //遍历类中方法寻找回调方法 findUsingReflectionInSingleClass(findState); &#125; //移到父类位置 findState.moveToSuperclass(); &#125; //将所有的注册方法返回 释放findState对象 return getMethodsAndRelease(findState); &#125; private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); // private static final int BRIDGE = 0x40; // private static final int SYNTHETIC = 0x1000; // private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC; // public方法 不是静态 抽象 桥接 不在源代码的方法 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //参数长度必须是1 if (parameterTypes.length == 1) &#123; //存在Subscribe的注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; //获取回调方法的运行线程 ThreadMode threadMode = subscribeAnnotation.threadMode(); //将回调方法放入到List中 //方法 参数类型 运行线程 运行优先级 是否为sticky方法 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); &#125; &#125; &#125; // Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //这个是关键 将消息实体作为KEY 回调方法作为Value加入Map 以后发送消息要用到 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; //按照优先级插入 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //粘性事件处理 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 发送逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public void post(Object event) &#123;//获取当前线程的发送List 并将改发送事件加入到List中 PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; //遍历发送 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125;private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; //根据消息实体类型获取父类消息实体 这个还需要看下 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //进行消息发送 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125;private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //根据消息实体类型找到回调方法的List subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; //发现消息 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125;private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; //在不同线程回调方法 case POSTING: //发送线程 invokeSubscriber(subscription, event); break; case MAIN: //当前在主线程直接回调 不在主线程添加到主线程发送队列通过Handler实现 if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; //通过Executors.newCachedThreadPool()+列表实现 backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: //每次启动一个新的线程去执行的 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; stickyEvents处理在Android开发中，Sticky事件只指事件消费者在事件发布之后才注册的也能接收到该事件的特殊类型。在注册的时候要查一遍 以往发送的粘性事件map 12345678910111213141516171819202122232425262728293031//粘性事件处理if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); //遍历Map找到已经注册的粘性事件(包括父类) 然后激励发送 if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125;&#125;//发送的时候加入到粘性事件map中public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; stickyEvents.put(event.getClass(), event); &#125; // Should be posted after it is putted, in case the subscriber wants to remove immediately post(event); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"源码梳理","slug":"源码梳理","permalink":"http://ericwyuan.com/tags/源码梳理/"}]},{"title":"Gradle(Android Studio) 生成jar包","slug":"Gradle-Android-Studio-生成jar包","date":"2018-08-30T09:06:54.000Z","updated":"2020-03-15T06:14:56.222Z","comments":true,"path":"Gradle-Android-Studio-生成jar包.html","link":"","permalink":"http://ericwyuan.com/Gradle-Android-Studio-生成jar包.html","excerpt":"","text":"AS默认生成aar格式的文件 有时候需要生成jar包 可以通过grable命令去生成 1234567891011121314151617181920212223242526272829303132//拷贝代码task copyClass(type: Copy) &#123; delete(&apos;build/libs/&apos;) from(&apos;build/intermediates/classes/debug&apos;) into(&apos;build/libs/class/&apos;)&#125;//拷贝并解压缩libs资源task copyUnzipLibClass() &#123; ant.unzip(src: &quot;libs/jar_1.jar&quot;, dest: &quot;build/libs/class/&quot;) ant.unzip(src: &quot;libs/jar_2.jar&quot;, dest: &quot;build/libs/class/&quot;) ant.unzip(src: &quot;libs/jar_3.jar&quot;, dest: &quot;build/libs/class/&quot;)&#125;//编译 Jartask buildJar(type: Jar) &#123; //最终的 Jar包名 archiveName = &quot;jar_name.jar&quot; //初始化资源路径集 from(&quot;build/libs/class/&quot;) //去除路径集下部分的资源 exclude &quot;**/R.class&quot; //集成下面的资源 include &quot;/com/**&quot; include &quot;/org/**&quot;&#125;copyClass.dependsOn(build)copyUnzipLibClass.dependsOn(copyClass)buildJar.dependsOn(copyUnzipLibClass)//运行 gradlew buildJar","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://ericwyuan.com/tags/Gradle/"}]},{"title":"Android MVP MVVM框架梳理 （二）","slug":"Android-MVP-MVVM框架梳理-（二）","date":"2018-03-13T03:03:52.000Z","updated":"2020-03-15T06:14:56.222Z","comments":true,"path":"Android-MVP-MVVM框架梳理-（二）.html","link":"","permalink":"http://ericwyuan.com/Android-MVP-MVVM框架梳理-（二）.html","excerpt":"","text":"Android MVP框架梳理 梳理下Google推荐的MVP MVVM Demo 源码Git地址 todo‑mvp todo‑mvp‑clean todo‑mvp‑dagger todo‑mvp‑rxjava todo‑mvvm‑databinding todo‑mvvm‑live todo‑mvp‑cleantodo‑mvp‑clean源码Git地址todo‑mvp‑clean与todo‑mvp对比 todo‑mvp‑clean在Presenter和TasksDataSource 之间加入了Domail Layout层 该层中可以减少Presenter的代码 使逻辑更清晰 todo‑mvp‑clean加入了UseCase和UseCaseHandler的机制 在非UI线程进行逻辑操作 在UI线程进行界面刷新 todo‑mvp‑clean结构图 todo‑mvp‑clean逻辑梳理todo‑mvp‑clean与todo‑mvp只是在Presenter和TasksDataSource之间逻辑处理有了变化 只梳理这部分的流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Presenter层调用UseCaseHandler去执行逻辑处理 * 处理完回调上层结果 通知界面刷新 * * @param title * @param description */private void createTask(String title, String description) &#123; Task newTask = new Task(title, description); if (newTask.isEmpty()) &#123; mAddTaskView.showEmptyTaskError(); &#125; else &#123; mUseCaseHandler.execute(mSaveTask, new SaveTask.RequestValues(newTask), new UseCase.UseCaseCallback&lt;SaveTask.ResponseValue&gt;() &#123; @Override public void onSuccess(SaveTask.ResponseValue response) &#123; mAddTaskView.showTasksList(); &#125; @Override public void onError() &#123; showSaveError(); &#125; &#125;); &#125;&#125;/** * 每个Presenter对应一个UseCaseHandler * UseCaseHandler中进行具体的逻辑处理 * * @param useCase * @param values * @param callback * @param &lt;T&gt; * @param &lt;R&gt; */public &lt;T extends UseCase.RequestValues, R extends UseCase.ResponseValue&gt; void execute( final UseCase&lt;T, R&gt; useCase, T values, UseCase.UseCaseCallback&lt;R&gt; callback) &#123; //设置请求过程中需要的参数 useCase.setRequestValues(values); //设置请求完成后的回调 useCase.setUseCaseCallback(new UiCallbackWrapper(callback, this)); EspressoIdlingResource.increment(); //逻辑处理放在非UI线程 mUseCaseScheduler.execute(new Runnable() &#123; @Override public void run() &#123; useCase.run(); if (!EspressoIdlingResource.getIdlingResource().isIdleNow()) &#123; EspressoIdlingResource.decrement(); &#125; &#125; &#125;);&#125;/** * 具体的业务处理 * GetTasks.java * * @param values 上层传来的参数 */@Overrideprotected void executeUseCase(final RequestValues values) &#123; if (values.isForceUpdate()) &#123; mTasksRepository.refreshTasks(); &#125; //此逻辑在非UI线程执行 //并对数据仓储设置回调 mTasksRepository.getTasks(new TasksDataSource.LoadTasksCallback() &#123; @Override public void onTasksLoaded(List&lt;Task&gt; tasks) &#123; TasksFilterType currentFiltering = values.getCurrentFiltering(); TaskFilter taskFilter = mFilterFactory.create(currentFiltering); List&lt;Task&gt; tasksFiltered = taskFilter.filter(tasks); ResponseValue responseValue = new ResponseValue(tasksFiltered); //处理结果回调上层进行处理( mAddTaskView.showTasksList();) getUseCaseCallback().onSuccess(responseValue); &#125; @Override public void onDataNotAvailable() &#123; ////处理结果回调上层进行处理( showSaveError();) getUseCaseCallback().onError(); &#125; &#125;);&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"Android MVP MVVM框架梳理","slug":"Android-MVP-MVVM框架梳理","permalink":"http://ericwyuan.com/tags/Android-MVP-MVVM框架梳理/"},{"name":"源码梳理","slug":"源码梳理","permalink":"http://ericwyuan.com/tags/源码梳理/"}]},{"title":"Android MVP MVVM框架梳理 （一）","slug":"Android-MVP-MVVM框架梳理-（一）","date":"2017-12-29T08:16:55.000Z","updated":"2020-03-15T06:14:56.221Z","comments":true,"path":"Android-MVP-MVVM框架梳理-（一）.html","link":"","permalink":"http://ericwyuan.com/Android-MVP-MVVM框架梳理-（一）.html","excerpt":"","text":"Android MVP框架梳理 梳理下Google推荐的MVP MVVM Demo 源码Git地址 todo‑mvp todo‑mvp‑clean todo‑mvp‑dagger todo‑mvp‑rxjava todo‑mvvm‑databinding todo‑mvvm‑live todo‑mvptodo‑mvp源码Git地址这个项目中还用到了guava room等框架包 会逐渐梳理出来~ 1.MVP简介MVC是基于MVC模式框架上发展而来的，在Android中代码框架中 大家都会使用MVC模式 MVC在代码中的应用如下: 123Modle:对应Bean对象和数据View:对应XML布局Control:对应Activity 但是Activity中经常需要处理View的好多逻辑业务，导致Activity业务很臃肿 复杂。MVP 模式可以很好的解决这种问题 使代码结构更清晰 业务更明确 更易于理解阅读MVP框架职责如下： 123Modle:依然对应Bean对象和数据View:对应Activity Fragment 只做View的展示 Presenter:支持人角色 负责业务逻辑处理 项目包结构如下： 项目类结构如下：除了util工具类 其余的包都是按照业务逻辑在自己的包中，每个包都符合MVP模式 2.包中功能解释2.1data包 1.定义了bean对象 Task2.定义了数据源的接口 TasksDataSource3.实现了数据仓库接口:本地数据仓库,远程数据仓库4.实现综合数据仓库TasksRepository 里边有本地和远程的数据仓库的对象 可以实现数据源的不同存储,缓存的功能 2.2 addedittask包addedittask,statistics,taskdetail,tasks里边有事一个MVP模式 只梳理下addedittask中的逻辑 其他包是类似的 1234AddEditTaskActivity:初始化View层和Presenter层 并实现Presenter和View的绑定AddEditTaskContract:定义了View和Presenter的接口AddEditTaskFragment:View层实现了AddEditTaskContract中的View接口AddEditTaskPresenter :Presenter层 实现了AddEditTaskContract的Presenter接口 2.2.1 AddEditTaskContract.java定义了View和Presenter的接口 123456789101112131415161718192021222324public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void saveTask(String title, String description); void populateTask(); boolean isDataMissing(); &#125;&#125; 2.2.2 AddEditTaskFragment.java12345678910111213141516171819202122//实现View层的接口public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; //点击事件交给Presenter层去处理 fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPresenter.saveTask(mTitle.getText().toString(), mDescription.getText().toString()); &#125; &#125;); //Presenter层处理完逻辑 回调之View层展现 @Override public void showEmptyTaskError() &#123; Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show(); &#125; @Override public void showTasksList() &#123; getActivity().setResult(Activity.RESULT_OK); getActivity().finish(); &#125; 2.2.3 AddEditTaskPresenter.java1234567891011121314151617181920212223//实现Presenter的接口public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback &#123; //处理View层发送来的请求 @Override public void saveTask(String title, String description) &#123; if (isNewTask()) &#123; createTask(title, description); &#125; else &#123; updateTask(title, description); &#125; &#125; private void updateTask(String title, String description) &#123; if (isNewTask()) &#123; throw new RuntimeException(\"updateTask() was called but task is new.\"); &#125; //交于综合数据仓库去处理数据 mTasksRepository.saveTask(new Task(title, description, mTaskId)); //处理完后回调View层展示处理结果 mAddTaskView.showTasksList(); // After an edit, go back to the list. &#125;&#125; 2.2.4 AddEditTaskActivity.java初始化View层和Presenter层 并实现Presenter和View的绑定 12345678910111213141516171819//初始化View层if (addEditTaskFragment == null) &#123; addEditTaskFragment = AddEditTaskFragment.newInstance();&#125;boolean shouldLoadDataFromRepo = true;// Prevent the presenter from loading data from the repository if this is a config change.if (savedInstanceState != null) &#123; // Data might not have loaded when the config change happen, so we saved the state. shouldLoadDataFromRepo = savedInstanceState.getBoolean(SHOULD_LOAD_DATA_FROM_REPO_KEY); &#125;//初始化View层和Presenter层 并实现Presenter和View的绑定mAddEditTaskPresenter = new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment, shouldLoadDataFromRepo); 2.2.5 TasksDataSource 数据处理相关的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void updateTask(String title, String description) &#123; if (isNewTask()) &#123; throw new RuntimeException(\"updateTask() was called but task is new.\"); &#125; //交于综合数据仓库去处理数据 mTasksRepository.saveTask(new Task(title, description, mTaskId)); //处理完后回调View层展示处理结果 mAddTaskView.showTasksList(); // After an edit, go back to the list.&#125;/** * 综合数据仓储处理 * TasksRepository.java * @param task */@Overridepublic void saveTask(@NonNull Task task) &#123; checkNotNull(task); //远程数据仓储处理 mTasksRemoteDataSource.saveTask(task); //本地数据仓储处理 mTasksLocalDataSource.saveTask(task); // 加入本地缓存 if (mCachedTasks == null) &#123; mCachedTasks = new LinkedHashMap&lt;&gt;(); &#125; mCachedTasks.put(task.getId(), task);&#125;/** * 本地数据存储 * 因为操作数据库需要放在非UI线程处理 * TasksLocalDataSource.java * @param task */@Overridepublic void saveTask(@NonNull final Task task) &#123; checkNotNull(task); //启动线程 在非UI进程进行数据库操作 Runnable saveRunnable = new Runnable() &#123; @Override public void run() &#123; mTasksDao.insertTask(task); &#125; &#125;; mAppExecutors.diskIO().execute(saveRunnable);&#125;/** * 远程数据操作处理 * 此处代码为模拟的 * TasksRemoteDataSource.java * * @param task */@Overridepublic void saveTask(@NonNull Task task) &#123; TASKS_SERVICE_DATA.put(task.getId(), task);&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"Android MVP MVVM框架梳理","slug":"Android-MVP-MVVM框架梳理","permalink":"http://ericwyuan.com/tags/Android-MVP-MVVM框架梳理/"},{"name":"源码梳理","slug":"源码梳理","permalink":"http://ericwyuan.com/tags/源码梳理/"}]},{"title":"格式化安卓字符串资源","slug":"格式化安卓字符串资源","date":"2017-02-15T05:18:29.000Z","updated":"2020-03-15T06:14:56.224Z","comments":true,"path":"格式化安卓字符串资源.html","link":"","permalink":"http://ericwyuan.com/格式化安卓字符串资源.html","excerpt":"","text":"格式化安卓字符串资源 每种语言按照默认的行数对应起来 每个资源必须单独一行 只支持String 不支持数组使用方法：1.放在res同目录下2.在translate_file_name中append需要格式化的文件名代码如下 格式及其不规范123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# coding=utf-8import fileinputimport osimport refrom xml.etree.ElementTree import ElementTreeRES = \"res\\\\\"DEFAULT_LANGUAGE = \"values\"# 通过xml格式读取默认的语言格式def read_xml(in_path): try: tree = ElementTree() tree.parse(in_path) return tree except BaseException: return None# 获取其他语言对应的字典def get_dict_from_other_language(file_path): other_language_dict = &#123;&#125; is_start_parser_string = False head_content = \"\" for line in fileinput.input(file_path): _pattern = r\"name=\\\"\" + \"\\w*\\\"\" pattern = re.compile(_pattern) result = pattern.findall(line) if len(result) &gt;= 1: if not is_start_parser_string: is_start_parser_string = True name = result[0][6:-1] other_language_dict[name] = line else: if not is_start_parser_string: head_content += line fileinput.close() return head_content, other_language_dict# 获取其他语言对应的字符串def get_string_for_other_language(other_language_dict, tree_default, head_content): result = head_content for node in tree_default.getroot(): node_name = node.attrib['name'] if node_name in other_language_dict: result += other_language_dict[node_name] else: result += (\" &lt;!-- \" + node_name + \" not translate --&gt;\\n\") result += \"&lt;/resources&gt;\" return result# 写文件def write_file(content, path): fp = open(path, mode=\"w\") try: fp.write(content) except BaseException: return None finally: fp.close()# 校验语言格式是否匹配def check_other_language(default_language_path, other_language_path): default_language_dict = &#123;&#125; default_index = 0 for line in fileinput.input(default_language_path): _pattern = r\"name=\\\"\" + \"\\w*\\\"\" pattern = re.compile(_pattern) result = pattern.findall(line) if len(result) &gt;= 1: name = result[0][6:-2] default_language_dict[default_index] = name default_index += 1 fileinput.close() other_language_dict = &#123;&#125; other_index = 0 for line in fileinput.input(other_language_path): _pattern = r\"name=\\\"\" + \"\\w*\\\"\" pattern = re.compile(_pattern) result = pattern.findall(line) if len(result) &gt;= 1: name = result[0][6:-1] other_language_dict[other_index] = name other_index += 1 fileinput.close() default_len = len(default_language_dict) other_len = len(other_language_dict) if default_len != other_len: print other_language_path + \" error!!!\" return for index in range(default_len): if cmp(default_language_dict[index], other_language_dict[index]) != 0: print default_language_dict[index], other_language_dict[ index], other_language_path + \" error!!!\" return print other_language_path, \"succeed\" return# 格式化安卓字符串资源 每种语言按照默认的行数对应起来 每个资源必须单独一行# 只支持String 不支持数组translate_file_name = []translate_file_name.append(\"strings.xml\")def format_android_string(): # 1. 通过xml格式读取默认语言的xml文件 # 2. 通过读文件方式读取其他语言的xml文件(通过正则表达式提取name属性/通过xml节点方式获取name属性) 生成name属性和该行的map数据对象 # 3. 根据name属性 从map数据对象中获取该行 # 4. 将读出来的该行 拼接到已经有的资源字符串后 # 5. 遍历完全部 生成文件 for fileName in translate_file_name: default_language_path = RES + DEFAULT_LANGUAGE + \"\\\\\" + fileName tree_default = read_xml(default_language_path) if tree_default is None: continue other_language_dir = os.listdir(RES) for otherLanguageFile in other_language_dir: if otherLanguageFile.startswith( \"values\") and not otherLanguageFile == DEFAULT_LANGUAGE: other_language_path = RES + otherLanguageFile + \"\\\\\" + fileName head_content, other_language_dict = get_dict_from_other_language( other_language_path) string_result = get_string_for_other_language(other_language_dict, tree_default, head_content) write_file(string_result, other_language_path) check_other_language(default_language_path, other_language_path)if __name__ == \"__main__\": format_android_string()","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"},{"name":"Python","slug":"Python","permalink":"http://ericwyuan.com/tags/Python/"}]},{"title":"Looper Handler MessageQueue源码解析","slug":"Looper-Handler-MessageQueue源码解析","date":"2017-02-07T07:17:22.000Z","updated":"2020-03-15T06:14:56.222Z","comments":true,"path":"Looper-Handler-MessageQueue源码解析.html","link":"","permalink":"http://ericwyuan.com/Looper-Handler-MessageQueue源码解析.html","excerpt":"","text":"##Looper Handler MessageQueue源码解析 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; 上边为谷歌推荐的Handler使用方法，通过以上代码 理解下Looper Handler MessageQueue相关代码 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));//保证每个线程只有一个Looper对象 &#125; Looper与MessageQueue绑定： 12345private Looper(boolean quitAllowed) &#123; //每个Looper唯一对应一个MessageQueue 即一个线程对应一个Looper 一个MessageQueue mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Looper自循环 1234567891011121314151617public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123;//无限循环 Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; msg.target.dispatchMessage(msg);//回调dispatchMessage方法 msg.recycleUnchecked(); &#125; &#125; 下面是Handler将消息添加到MessageQunue的流程： 123456789101112131415161718192021222324252627282930313233343536373839boolean enqueueMessage(Message msg, long when) &#123; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException(msg.target + \" sending message to a Handler on a dead thread\"); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; // 最后一个p为null 将message插入到倒数第二个位置 &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 以上就是Looper Handler MessageQueue实现线程间通信的大致逻辑~","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"}]},{"title":"账户平台梳理","slug":"账户平台梳理","date":"2017-01-23T13:41:51.000Z","updated":"2020-03-15T06:14:56.224Z","comments":true,"path":"账户平台梳理.html","link":"","permalink":"http://ericwyuan.com/账户平台梳理.html","excerpt":"","text":"工作以来一直负责自己公司的账户平台的开发与维护，也接入过谷歌,Facebook,微信,QQ,微博,360各家平台的账户SDK,现在记录下账户平台应该实现的功能模块，大致思路，以及遇到的坑 主要内容 登录方式考虑:支持多种方式登录 单点登录，授权方式登录，默认方式登录 对外接口设计考虑:接口简单，易于理解 第三方接入考虑:接入方式简单，便于操作 日志打印，定位问题 遇到的坑 登录方式考虑:单点登录必须牵扯多进程数据交互，通常考虑通过aidl,startActivityForResult,ContentProvider,settings数据库等方式中的一种或者多种来实现 aidl 推荐使用该方式，第三方集成账户SDK的应用通过aidl接口访问账户服务调用相关接口来实现单端登录 (账户服务可以是一个或者多个，一个的话集成账户SDK的应用固定的调用一个包名中的服务去获取数据，如果是多个可以通过某种算法（数据写入实现，最近更新时间等方式）固定每次选择到同一个包名中的服务来获取相关该数据)我觉得百度现在应该通过多个应用中都有账户服务的方案来实现的，他没有一个用户量很大的应用，并且每次登录时会告诉你 你的账号信息是从哪个应用读取来的 startActivityForResult 通过startActivityForResult方式拉起账户应用，来获取相关的数据实现单点登录，实现效果类似于QQ登录 通过startActivityForResult的方式，在onActivityResult中获取返回的数据 通过ContentProvider对外提供数据，第三方集成账户SDK的应用可以获取到数据 通过settings数据库实现，第三方集成账户SDK的应用需要登录账号时先去看下setting数据库中有没有相关的数据，有的话就去使用该数据去进行相应的操作，需要注意读写权限的控制，哪些应用具有写权限，哪些应用具有读权限 最简单的实现方式 最不推荐的实现方式，Android6.0以后setting数据库权限控制的比较严了，存在应用卸载安装后账户数据依旧存在的问题(有的设备厂商还正需要该功能) 对外接口设计考虑: 接口设计必须做到少而精 见名知义 主要接口设计考虑 内部应用登录使用login(Activity,Bundle,Handle,OnListener())，接口中所有的操作对外不可见，读取本地登录票据数据，校验本地登录票据合法性，使用系统票据生成本地票据等操作，一把完成登录所有流程 外部应用使用getAuthCode(Activity,Bundle,Handle,OnListener())，外部应用一般走Oauth2协议，获取到临时授权码，再通过服务器获取票据 其余接口设计考虑 Token合法性校验 用户信息获取 支付相关业务 第三方接入考虑 现在对外提供SDK一般有三种方式 aar 最新 最好 最简单的方式 但是好多应用因为历史原因，不能使用aar的SDK 新版本SDK建议使用该方式 别人集成简单呀 权限，Activity，广播啥都不需要声明 直接调用接口就行 lib工程的方式 资源放在res目录 重要代码写成jar放在lib工程的lib目录下，其余代码可以在src中 不牵扯到代码保密的话也可以 jar包的方式 如果提供的SDK有界面 需要将界面资源 字符串资源 图片资源特殊处理 流程比较复杂 第三方应用还需要在自己的AndroidManifest中声明相关东西，但是不需要对外提供任何代码 保密性比较好,总之不推荐使用 日志打印，定位问题这是所有应用必须考虑的问题，好的日志打印应该满足一下要求 错误日志需要打印出上下文 不是告诉你程序在这里错了 需要通过日志可以看出为什么错了 日志在于精，并且不能多，打出有用日志 日志的格式进程号，线程号，代码执行的行数 (TAG,”[parameter1 : “+parameter1+”][parameter2 : “+parameter+”] methodname result : (result1,result2,result3)”) 遇到的坑 接口设计 界面相关的必须用Activity不能用Context 坑坑坑啊～ 票据分类 不同票据访问权限控制 根票据 应用票据 临时票据 临时授权码 AndroidManifest配置检查 有的第三方不按照文档声明Activity 广播 权限 需要做声明检查 将问题在开发阶段就暴露出来 需要使用任何第三方库 v4 httpclient eventbus等 你用了其中的东西 有的第三方应用不使用,使用的是自己修改后的,使用的跟你的版本不一致;存在很多未知问题 洋洋散散就这些 自己做的总结以及思考","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"}]},{"title":"getDeviceId() 接口说明","slug":"getDeviceId-接口说明","date":"2017-01-23T07:07:22.000Z","updated":"2020-03-15T06:14:56.223Z","comments":true,"path":"getDeviceId-接口说明.html","link":"","permalink":"http://ericwyuan.com/getDeviceId-接口说明.html","excerpt":"","text":"12345678910111213141516171819/** * Returns the unique device ID, for example, the IMEI for GSM and the MEID * or ESN for CDMA phones. Return null if device ID is not available. * * &lt;p&gt;Requires Permission: * &#123;@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE&#125; */public String getDeviceId() &#123; try &#123; ITelephony telephony = getITelephony(); if (telephony == null) return null; return telephony.getDeviceId(mContext.getOpPackageName()); &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125;&#125; 正常情况下 getDeviceId()这个接口的返回值和当时卡槽注册的phone有关 如果注册的是CDMA 返回的是Meid如果注册是的GMS网络 返回的是imei如果一直没插卡 没注册phone默认获取imei调用getDeviceId() 返回值： 不插卡怎么读不插卡的话 会保持上一次插卡是的phone状态 即上一次插得是CDMA的 获取的是MEID 插得是GMS的 获取的是IMEI如果之前一直没有插过卡 默认获取IMEI 插一个怎么读插得是CDMA卡获取MEID 插得是GMS卡获取的是IMEI 不插卡的卡槽同问题 插两个怎么读哪个卡槽插得是CDMA卡获取的是MEID 哪个卡槽插得是GMS卡获取的是IMEI 插了再拔出来怎么读插出来后保持上一次的状态 同问题1 移动联通怎么读，电信怎么读建议统一调用getimei(int)这个接口 这个接口不管手机注册的什么网络 均返回imei 不会根据插的卡而改变返回值","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"}]},{"title":"Java中的异常总结","slug":"Java中的异常总结","date":"2016-07-13T02:48:14.000Z","updated":"2020-03-15T06:14:56.222Z","comments":true,"path":"Java中的异常总结.html","link":"","permalink":"http://ericwyuan.com/Java中的异常总结.html","excerpt":"","text":"1.1按照继承关系 分为Error和ExceptionError：大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。常见的有：StackOverflowError OutOfMemoryErrorException：是程序本身可以处理的异常。太多了 不举例了 在Eclipse中 鼠标放在类名上 Ctrl+T 显示继承关系 RunTimeException：运行时的异常 Other：Exception和其子类中 除了RunTimeException以外的其余异常1.2 按照是否在编译的时候做检查 可以分为unchecked exception和unchecked exception：在编译的时候 不用检查的异常checked exception：在编译的时候 检查的异常 必须cactch 不然无编译已通过 1234567891011121314151617181920212223242526public class Main &#123; public static void main(String[] args) &#123; Main mMain = new Main(); try &#123; mMain.other(); &#125; catch (Exception e ) &#123; // 必须catch 不然无法编译通过 &#125; // 无须catch 可以編譯運行通過 mMain.runtimeException(); mMain.error(); &#125; private void error() throws Error &#123; throw new Error(\"error\" ); &#125; private void other() throws Exception &#123; throw new Exception(\"other\"); &#125; private void runtimeException() throws RuntimeException &#123; throw new RuntimeException(\"runtimeException\"); &#125;&#125; 关于catch中有return finally中的代码如何执行12345678910111213141516171819202122232425262728293031323334353637public class FinaliyTest &#123; static int i = 0; int testExReturn() throws Exception &#123; try &#123; testEx1(); i++; System.out.println(\"try i : \" + i); &#125; catch (Exception e) &#123; i++; System.out.println(\"catch i : \" + i); return i; &#125; finally &#123; i++; System.out.println(\"finally i : \" + i); // case 1 return i; &#125; // case 2 return i; &#125; void testEx1() throws Exception &#123; throw new Exception(); &#125; public static void main(String[] args) &#123; FinaliyTest mFinaliyTest = new FinaliyTest(); try &#123; int k = mFinaliyTest.testExReturn(); System.out.println(k); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(i); &#125;&#125; Case 1输出catch i : 1finally i : 22 2Case 2 输出catch i : 1finally i : 21 2总结：1.finally中的代码始终会运行 即使catch中有return finally中的代码依旧会运行2.如果finally中有return 则不会执行catch中return","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ericwyuan.com/tags/Java/"}]},{"title":"Android获取界面的返回结果","slug":"Android获取界面的返回结果","date":"2015-12-03T03:44:24.000Z","updated":"2020-03-15T06:14:56.222Z","comments":true,"path":"Android获取界面的返回结果.html","link":"","permalink":"http://ericwyuan.com/Android获取界面的返回结果.html","excerpt":"","text":"异步获取界面的返回结果，不需要使用onActivityResult，去接收界面的返回数据，如果接入过QQ 微博的账号系统，会知道他们会将登陆结果返回在onResult onError onCanel方法中。原理就是aidl 下文介绍如何实现。 aidl接口 1.实现aidl回调接口12345678910111213141516171819/** * The interface used to return responses from activity */oneway interface IActivityResponse &#123; /** * onResult */ void onResult(int code, Bundle value); /** * onError */ void onError(int error, String message); /** * onCancel */ void onCancel();&#125; 2.实现ActivityResponse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class ActivityResponse implements Parcelable &#123; // creator public static final Creator&lt;ActivityResponse&gt; CREATOR = new Creator&lt;ActivityResponse&gt;() &#123; public ActivityResponse createFromParcel(Parcel source) &#123; return new ActivityResponse(source); &#125; public ActivityResponse[] newArray(int size) &#123; return new ActivityResponse[size]; &#125; &#125;; /** * 日志 */ private static final String TAG = \"ActivityResponse\"; /** * 响应接口对象 */ private IActivityResponse response = null; /** * 构造函数 * * @param response IAccountResponse对象 */ public ActivityResponse(IActivityResponse response) &#123; this.response = response; &#125; /** * 构造函数 * * @param parcel Parcel对象 */ public ActivityResponse(Parcel parcel) &#123; response = IActivityResponse.Stub.asInterface(parcel.readStrongBinder()); &#125; /** * 回调并返回结果 * * @param result 数据结果 */ public void onResult(Bundle result) &#123; try &#123; response.onResult(result); &#125; catch (DeadObjectException e) &#123; LOG.e(TAG, \"[result:\" + result + \"] on result failed(DeadObjectException)\", e); &#125; catch (RemoteException e) &#123; LOG.e(TAG, \"[result:\" + result + \"] on result failed(RemoteException)\", e); &#125; catch (Throwable e) &#123; LOG.e(TAG, \"[result:\" + result + \"] on result failed(Throwable)\", e); &#125; &#125; /** * 发生错误时的回调 * * @param error 错误码 * @param message 错误信息 */ public void onError(int error, String message) &#123; try &#123; response.onError(error, message); &#125; catch (DeadObjectException e) &#123; LOG.e(TAG, \"[error:\" + error + \"][message:\" + message + \"] on error failed(DeadObjectException)\", e); &#125; catch (RemoteException e) &#123; LOG.e(TAG, \"[error:\" + error + \"][message:\" + message + \"] on error failed(RemoteException)\", e); &#125; catch (Throwable e) &#123; LOG.e(TAG, \"[error:\" + error + \"][message:\" + message + \"] on error failed(Throwable)\", e); &#125; &#125; /** * 发生取消时的回调 */ public void onCancel() &#123; try &#123; response.onCancel(); &#125; catch (DeadObjectException e) &#123; LOG.e(TAG, \"on cancel failed(DeadObjectException)\", e); &#125; catch (RemoteException e) &#123; LOG.e(TAG, \"on cancel failed(RemoteException)\", e); &#125; catch (Throwable e) &#123; LOG.e(TAG, \"on cancel failed(Throwable)\", e); &#125; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeStrongBinder(response.asBinder()); &#125; 3.将IActivityResponse.Stub传入Activity，并实现回调方法1234567891011121314151617i.putExtra(\"activityResponse\", new ActivityResponse(new IActivityResponse.Stub()&#123; @Override public void onResult(Bundle value) throws RemoteException &#123; &#125; @Override public void onError(int error, String message) throws RemoteException &#123; &#125; @Override public void onCancel() throws RemoteException &#123; &#125; &#125;)); 4.在Activity中调用1234567891011121314151617ActivityResponse response = getIntent().getParcelableExtra(\"activityResponse\");if (null != response) &#123; response.onError(error, message);&#125;ActivityResponse response = getIntent().getParcelableExtra(\"activityResponse\");if (null != response) &#123; response.onResult(result);&#125;ActivityResponse response = getIntent().getParcelableExtra(\"activityResponse\");if (null != response) &#123; response.onCancel();&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://ericwyuan.com/categories/开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ericwyuan.com/tags/Android/"}]}]}